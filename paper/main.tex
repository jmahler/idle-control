
% {{{ preamble

%\documentclass[10pt,letterpaper]{article}
\documentclass{article}
%\documentclass[twocolumn]{article}
%\documentclass[12pt]{report}

%\usepackage{url}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{nonfloat}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{parskip}
\usepackage{fullpage}

\usepackage{tikz}
\usetikzlibrary{calc,arrows,positioning,shadows}
%
% control system tikz objects
\tikzset{shadow/.style={drop shadow,fill=white}}
\tikzset{sum/.style={circle,draw,very thick,shadow,minimum size=5mm}}
\tikzset{sumnp/.style={sum,
				label={{above left,xshift=0.0mm,yshift=-1.0mm}:$+$},
				label={{below right,xshift=-1.0mm,yshift=0.0mm}:$-$}} }
\tikzset{sumpp/.style={sum,
				label={{above left,xshift=0.0mm,yshift=-1.0mm}:$+$},
				label={{below right,xshift=-1.0mm,yshift=0.0mm}:$+$}} }
\tikzset{sumpn/.style={sum,
				label={{below left,xshift=0.0mm,yshift=1.0mm}:$+$},
				label={{above right,xshift=-1.0mm,yshift=0.0mm}:$-$}} }
\tikzset{sumxpxp/.style={sum,
				label={{above left,xshift=0.0mm,yshift=-1.0mm}:$+$},
				label={{above right,xshift=-0.0mm,yshift=-1.0mm}:$+$}} }
\tikzset{sumxpxn/.style={sum,
				label={{above left,xshift=0.0mm,yshift=-1.0mm}:$+$},
				label={{above right,xshift=-0.0mm,yshift=-1.0mm}:$-$}} }
\tikzset{gain/.style={rectangle,draw,very thick,inner sep=2mm,shadow}}

\usepackage{listings}
\lstset{numbers=left,
		language=Matlab,
		basicstyle=\footnotesize,
		captionpos=b,
		showspaces=false,
		showstringspaces=false,
		xleftmargin=0.3in}

\usepackage{sectsty}  % \sectionfont
%\sectionfont{\normalsize}
%\subsectionfont{\normalsize}

\raggedright
%\setlength{\parindent}{0.2in}

% prevent breaks in the middle of paragraphs
\widowpenalties 1 10000
\raggedbottom

%
% backend	: biber
% style		: numeric
% autocite	: footnote
% citestyle	: verbose-inote
% bibstyle	: authortitle, numeric
%
\usepackage[backend=biber,autocite=footnote,
			bibstyle=authortitle,citestyle=verbose-inote]{biblatex}

\addbibresource{main.bib}
\setlength\bibitemsep{1em}

% }}}

\begin{document}

% {{{ title page

\thispagestyle{empty}

\vspace*{1.0in}
\centerline{\Large \textbf{Control System Design Applied to}}
\centerline{\Large \textbf{Idle Stabilization of a Spark Ignition Engine}}
\vspace{0.1in}
\centerline{\normalsize {Jeremiah Mahler}}
\centerline{\small {\href{mailto:jmahler@mail.csuchico.edu}{jmahler@mail.csuchico.edu}} }
\vspace{0.1in}
\centerline{\normalsize {California State University Chico}}
\centerline{\small \today}
%\vspace{0.2in}
%\centerline{\LARGE \textbf{DRAFT}}
\vspace{0.5in}

\vfill

\begin{abstract}
\noindent
The task of maintaining a stable idle for an internal combustion
engine with spark ignition is non-trivial.
Any time an accessory is turned on/off the torque applied to
the engine changes.
And changes in torque will change the engine rpm if the control
inputs are constant.
This paper shows how control system methods can be applied to
the problem of idle stabilization.
Because the engine model is inherently discrete all of the methods
used are also discrete.
Methods include: pole placement, direct design, and
various state space designs.
\end{abstract}

\vspace{1.5in}

% }}}


\clearpage
\tableofcontents

% {{{ Engine Model
\clearpage
\section{Engine Model}

The engine model used here is based work
by Butts and Sivashankar\autocite{532315} which was derived from
the work by Powell and Cook\autocite{4789342}.
The configuration is a modern 4.6L V-8 gas engine.
To simplify this analysis the linearized model was used as shown in
Figure \ref{fig:lem}.

% {{{ fig:lem
\begin{figure}[hbp!]
\begin{center}

\begin{tikzpicture}[>=triangle 60, scale=0.6,
	node distance=14mm, auto]

	\node[gain] 	(gain1)	[]					{$1.699$};
	\node[sumnp]  	(sum1)	[right=of gain1] 	{};
	\node[gain] 	(gain2)	[right=of sum1]		{$\dfrac{8.5683}{z^2-0.9025z}$};
	\node[sumpn]  	(sum2)	[right=of gain2] 	{};
	\node[gain] 	(gain3)	[right=of sum2]		{$\dfrac{2.98}{z - 0.9354}$};
	\node[gain] 	(gain4)	[below=of sum2]		{$0.00093$};

	\draw [->] (-30mm,0) node[above,xshift=2mm,yshift=1mm]{$\Delta \text{control}$}
				-- (gain1.west);
	\draw [->] (gain1) -- (sum1);
	\draw [->] (sum1) -- (gain2);
	\draw [->] (gain2) -- (sum2);
	\draw [->] (sum2) -- (gain3);
	\draw [->] (gain3.east) -- ++(30mm,0) node[above,xshift=-5mm,yshift=1mm]{$\Delta \text{rpm}$};
	\draw [->] ($(gain3.east) + (10mm,0) $) |- (gain4.east);
	\draw [->] (gain4.west) -| (sum1.south);
	\draw [<-] (sum2.north) -- ++(0,10mm) node[above]{$\Delta \text{torque}$};
\end{tikzpicture}

\end{center}
\caption{Linear engine model of a modern 4.6L V-8.}\label{fig:lem}
\end{figure}
% }}}

This model takes two inputs: a torque, and a idle control signal.
When the torque is greater than zero it will oppose the rotation of
the engine causing it to slow down.
The idle control signal is some fraction of unity.
This fraction corresponds to a pulse width modulated idle control valve
which is at a minimum near zero and at a maximum near unity.

Because all the inputs and outputs are defined as deltas ($\Delta$)
this model cannot be used directly with typical control systems
which expect steady state values.
It is possible to convert these deltas to steady state equivalents.
Figure \ref{fig:sdtf} shows the transfer function to convert steady
state values to delta values
\footnote{The derivation of the steady state to delta conversion
is given in Appendix \ref{app:cdelta}}.
Figure \ref{fig:dstf} shows the transfer function to delta values
to steady state values
\footnote{The derivation of the delta to steady state conversion
is given in Appendix \ref{app:dsderiv}.}.

% {{{ fig:sdtf
\begin{figure}[!htbp]
\begin{center}
\begin{tikzpicture}[>=triangle 60]
\node[gain] (gain1) [] {$1 - z^{-1}$};
\draw [->] (-20mm,0) node[above,yshift=1mm]{$X$} -- (gain1.west);
\draw [->] (gain1.east) -- (20mm,0) node[above,yshift=1mm]{$\Delta X$};
\end{tikzpicture}
\end{center}
\caption[xyz]{The $Z$ transform used to accumulate the input and convert
a steady state input to delta output.}
\label{fig:sdtf}
\end{figure}

% }}}

% {{{ fig:dstf
\begin{figure}[!htbp]

\begin{center}
\begin{tikzpicture}[>=triangle 60]
\node[gain] (gain1) [] {$\dfrac{1}{1 - z^{-1}}$};
\draw [->] (-20mm,0) node[above,yshift=1mm]{$\Delta X$} -- (gain1.west);
\draw [->] (gain1.east) -- (20mm,0) node[above,yshift=1mm]{$X$};
\end{tikzpicture}
\end{center}

\caption{The $Z$ transform used to convert delta input to a steady
state output.}
\label{fig:dstf}

\end{figure}
% }}}

Typical control systems have an associated time step.
And the choice of this time step is crucial in determining performance
with regard to the Nyquist frequency.
However this model does not suffer from this issue because it is
inherently discrete.
A single ignition event of the engine corresponds to a single
step of the model.

In order to construct a controller the model (Figure \ref{fig:lem})
needs to be simplified in to a transfer function.
However the prescence of two inputs, control and torque, complicates matters.
To resolve this issue the torque can be set zero.
Then it can be simplified by recognizing that it matches
the well known form shown in Figure \ref{fig:dd} which
has the transfer function in Equation \ref{eq:dd}.

% {{{ dd figure
\begin{figure}[h!]

\begin{center}
\begin{tikzpicture}[>=triangle 60, scale=0.8,
	node distance=20mm, auto]

	\node[gain]		(K) 	[] 				{$K$};
	\node[sumnp]	(sum1) 	[right of=K] 	{};
	\node[gain]		(Gz) 	[right of=sum1]	{$G(z)$};
	\node[gain]		(Dz) 	[below of=Gz] 	{$D(z)$};

	\draw [<-] (K) -- ++(-20mm,0) node[above]{$u$};
	\draw [->] (K) -- (sum1);
	\draw [->] (sum1) -- (Gz);
	\draw [<-] (sum1) |- (Dz);
	\draw [->] (Gz) -- ++(35mm,0) node[above]{$y$};
	\draw [->] (Gz) -- ++(20mm,0) |- (Dz.east);
\end{tikzpicture}
\end{center}

\caption{Direct Design system with $K$ as a scaling input, $G$ is
the plant and $D$ is the controller.}
\label{fig:dd}
\end{figure}
% }}}

\begin{align}
\frac{y}{u} &= K \frac{B \alpha}{A \alpha + B \beta} \label{eq:dd}
\end{align}

To simply first gather the parts from the engine model (Figure \ref{fig:lem}).

\begin{align*}
	\frac{B}{A} &= \frac{8.5683}{(z^2 - 0.9025z)} \frac{2.98}{(z - 0.9354)} \\
	K &= 1.699 \\
	\frac{\beta}{\alpha} &= 0.00093 
\end{align*}

\begin{samepage}
Then substitute them in to Equation \ref{eq:dd} and simplify.
The result is Equation \ref{eq:lems}.
\begin{align}
	\frac{y}{u} &= \frac{(1.699) (8.5683) (2.98) (1)}
		{(z^2 - 0.9025z)(z - 0.9354)(1) + (8.5683)(2.98)(0.00093)} \notag \\
	\Aboxed{ \frac{y}{u} &= \frac{43.38}{z^3 - 1.838 z^2 + 0.8442 z + 0.02375}}
		\label{eq:lems}
\end{align}
\end{samepage}

\begin{samepage}
It is still necessary to address the delta inputs and outputs.
This can be resolved by placing the conversion transforms
(from Figure \ref{fig:sdtf} and \ref{fig:dstf}) on either
end of the engine model as shown in Figure \ref{fig:nodelta}.
A beneficial side effect becomes apparent in this form.
The transform that converts from steady state to a delta cancels
with the transform that converts from a delta to steady state
\footnote{In the more general case, when torque is not zero,
the transforms wouldn't cancel.}.
Therefore the final transform is still Equation \ref{eq:lems}.
An example of the output response with no control is shown in
Figure \ref{fig:em_plot}.
The Matlab source code for this plot and others are
in Appendix \ref{app:em_matlab}.
\end{samepage}

% {{{ fig:nodelta
\begin{figure}[!htbp]

\begin{center}
\begin{tikzpicture}[>=triangle 60,
	node distance=30mm, auto]

\node[gain] (gain1) [] {$1 - z^{-1}$};
\node[gain] (engine) [right of=gain1] {engine};
\node[gain] (gain3) [right of=engine] {$\dfrac{1}{1 - z^{-1}}$};

\draw [->] (-25mm,0) node[above]{$u$} -- (gain1.west);
\draw [->] (gain1.east) node[above,xshift=6mm]{$\Delta u$} -- (engine);
\draw [->] (engine.east) node[above,xshift=6mm]{$\Delta y$} -- (gain3);
\draw [->] (gain3.east) -- ++(20mm,0) node[above]{$y$};
\end{tikzpicture}
\end{center}

\caption{Engine model with transforms for converting from steady state
to delta and vice versa.}
\label{fig:nodelta}

\end{figure}
% }}}

% {{{ fig:em_plot
\begin{figure}[htbp!]
\begin{center}
\includegraphics[scale=0.7]{../matlab/em_plot1}
\end{center}
\caption{Output response of engine model with no control.
The control can range from zero to one.
Here the control is constant at 0.65 which resulted in a stable
rpm near 900.}
\label{fig:em_plot}
\end{figure}
% }}}

It is not apparent from Figure \ref{fig:em_plot} exactly how long
this process takes because the $x$ axis represents ignition events
instead of time.
However the rpm can be converted to time per ignition event by examining
the units as shown in Equation \ref{eq:rpmtime}.

\begin{align}
\frac{1}{x \frac{\text{rev}}{\text{min}}
			\cdot n \frac{\text{ign}}{\text{rev}}
			\cdot \frac{\text{min}}{60\text{sec}}
		}
&= y \frac{\text{sec}}{\text{ign}} \label{eq:rpmtime} \\
& \notag \\
	\frac{\text{rev}}{\text{min}} &: \text{revolutions per minute (rpm)} \notag \\
	\frac{\text{ign}}{\text{rev}} &: \text{number ignition points per revolution (4 for 8 cylinder engine)} \notag \\
	\frac{\text{sec}}{\text{ign}} &: \text{seconds per ignition point} \notag
\end{align}

Applying Equation \ref{eq:rpmtime} results in the response shown
in Figure \ref{fig:rpmtime_plot}.
It can be seen that the rise time is over $0.5$ second and
that the overshoot is close to $40\%$.
The stabilization time is also several seconds.
Clearly its performance could be improved with the application
of a controller.

% {{{ fig:rpmtime_plot
\begin{figure}[htbp!]
\begin{center}
\includegraphics[scale=0.7]{../matlab/em_plot2}
\end{center}
\caption{Engine rpm response compared to time with a constant
0.65 input control.}
\label{fig:rpmtime_plot}
\end{figure}
% }}}

The response from zero rpm is not a realistic measurement of performance
because zero rpm is impossibly slow.
A typical idle rpm range is from 600 to 1000 rpm.
Figure \ref{fig:em_plot4} shows the response for a step input
with control inputs chosen to reach 600 and 1000 rpm
\footnote{The control input to stable rpm values are given in
Appendix \ref{app:contrpm}}.
This is a more realistic representation of typical operation.
The rise time is near $0.2$ seconds and the overshoot is $15\%$.
And the stabilization time is almost one second.
Its behavior can still be improved with a controller.

% {{{ fig:em_plot4
\begin{figure}[htbp!]
\begin{center}
\includegraphics[scale=0.6]{../matlab/em_plot4}
\end{center}
\caption{Response for a shifted and scaled step input with zero torque.}
\label{fig:em_plot4}
\end{figure}
% }}}

% }}}

\clearpage

% {{{ Direct Design
\section{Direct Design}

There are several characteristics of this Direct Design method.
The controller is built entirely in the discrete domain.
If the plant ($G(z)$) is continuous it is converted to discrete
using a Zero Order Hold.
In this case it is already discrete.
It is a pole placement technique where the desired roots of the
entire system are specified by the designer.
The controller values for $\beta$ and $\alpha$ are found using the
Diophantine equation along with a Sylvester matrix.
And the gain ($K$) is chosen such that the desired limit is reached.
Figure \ref{fig:ddc} shows the structure of the system.

% {{{ fig:ddc
\begin{figure}[h!]

\begin{center}
\begin{tikzpicture}[>=triangle 60, scale=0.8,
	node distance=20mm, auto]

	\node[gain]		(K) 	[] 				{$K$};
	\node[sumnp]	(sum1) 	[right of=K] 	{};
	\node[gain]		(Gz) 	[right of=sum1]	{$G(z)$};
	\node[gain]		(Dz) 	[below of=Gz] 	{$D(z)$};

	\draw [<-] (K) -- ++(-20mm,0) node[above]{$u$};
	\draw [->] (K) -- (sum1);
	\draw [->] (sum1) -- (Gz);
	\draw [<-] (sum1) |- (Dz);
	\draw [->] (Gz) -- ++(35mm,0) node[above]{$y$};
	\draw [->] (Gz) -- ++(20mm,0) |- (Dz.east);

	% add B/A labels
	\node [right of=Gz,node distance=0cm,xshift=9mm,yshift=6mm] {$\dfrac{B}{A}$};
	\node [right of=Dz,node distance=0cm,xshift=9mm,yshift=6mm] {$\dfrac{\beta}{\alpha}$};
\end{tikzpicture}
\end{center}

\caption{Direct Design system where $K$ is the scaling input, $G$ is
the plant and $D$ is the controller.}
\label{fig:ddc}
\end{figure}
% }}}

In this case the roots were not given and no deterministic way
was available to find them.
So trial and error was used.

\begin{align*}
	\text{roots} &: z = 0.6 \pm 0.4i
\end{align*}

Since the plant is already in discrete form it is not necessary
to use a Zero Order Hold.
The engine model, repeated from Equation \ref{eq:lems}, is shown below.
\begin{align*}
G(z) &= \frac{43.38}{z^3 - 1.838 z^2 + 0.8442 z + 0.02375} \\
	&= \frac{B(z)}{A(z)} = \frac{b_0 z^3 + b_1 z + b2}
								{a_0 z^3 + a_1 z + a2}
\end{align*}

Next it must be arranged to place it in the form of the Diophantine Equation.

From the block diagram the equation describing the system is found.
\begin{align*}
	\frac{y}{h} &= H \\
	H &= K \frac{G}{1 + D G} \\
	H &= K \frac{B \alpha}{A \alpha + B \beta}
\end{align*}

From the roots $D$ is constructed.
\begin{align*}
	D(z) &= (0.6 + 0.4i)(0.6 - 0.4i) \\
	D(z) &= z^2 - 1.2z + 0.520
\end{align*}

Recall the form of the Diophantine Equation where the order is $n$.
\[
\begin{array}{ccccccc}
	\alpha(z) &A(z) &+ &\beta(z) &B(z) &= &D \\
	  (n-1)   &(n)  &  & (n-1)  &(n) & &(2n-1)
\end{array}
\]

Since $A(z)$ is a third order polynomial $n = 3$.
This requires that $D(z)$ be a fifth order polynomial ($2n-1$).
The order is increased by adding zeros.

\begin{align*}
	D(z) &= z^5 - 1.2z^4 + 0.520z^3 \\
		 &= d_0z^5 + d_1z^4 + d_2z^3 + d_3z^2 + d_4z + d_5
\end{align*}

This also requires that $\alpha$ and $\beta$ are
second order polynomials ($n-1$).

\begin{align*}
	\frac{\beta}{\alpha} &= \frac{\beta_0 z^2 + \beta_1 z + \beta_2}
								{\alpha_0 z^2 + \alpha_1 z + \alpha_2}
\end{align*}

To solve the Diophantine Equation

\begin{align*}
	M &= E^{-1} D \\
	\left[
	\begin{array}{l}
		\alpha \\
		\beta
	\end{array}
	\right] &= E^{-1} D \\
	\left[
	\begin{array}{l}
		\alpha \\
		\beta
	\end{array}
	\right] &= 
	\left[
	\begin{array}{l}
		\alpha_2 \\
		\alpha_1 \\
		\alpha_0 \\
		\beta_2 \\
		\beta_1 \\
		\beta_0
	\end{array}
	\right]
\end{align*}

a third order Sylvester Matrix is required.

\[
E=
\begin{bmatrix}
	a_3 & 0 & 0 & b_3 & 0 & 0 \\
	a_2 & a_3 & 0 & b_2 & b_3 & 0 \\
	a_1 & a_2 & a_3 & b_1 & b_2 & b_3 \\
	a_0 & a_1 & a_2 & b_0 & b_1 & b_2 \\
	0 & a_0 & a_1 & 0 & b_0 & b_1 \\
	0 & 0 & a_0 & 0 & 0 & b_0 \\
\end{bmatrix}
\]

Combining these parts and solving for $\alpha$ and $\beta$ results
in a solution for $D(z)$.

\begin{align*}
	\Aboxed{
	\frac{\beta}{\alpha} &= D(z) = \frac{0.02297 z^2 - 0.01686 z - 0.0004643}
								{z^2 + 0.6379 z + 0.8482}
	}
\end{align*}

\begin{samepage}
The gain ($K$) still needs to be found and this can be accomplished
using the limit.
\begin{align*}
\lim_{z \to 1} &K \frac{B \alpha}{A \alpha + B \beta} = 1\\
\lim_{z \to 1} &K \frac{(43.38) (z^2 + 0.6379 z + 0.8482)}
	{(z^5 - 1.2z^4 + 0.520z^3)} = 1 \\
K &= \frac{(1 - 1.2 + 0.520)}{(43.38)(1 + 0.6379 + 0.8482)} \\
\Aboxed{ K &= 0.0029671 }
\end{align*}
\end{samepage}

This solution results in the response shown in Figure \ref{fig:dd_plot2}.
It is a dramatic improvement compared to no control.
The rise time, percent overshoot, and settling time are all improved.
This result is particularly interesting because the chosen roots were a guess.
It is likely that further improvement could be made by optimizing the roots.

% {{{ fig:dd_plot2
\begin{figure}[htbp!]
\begin{center}
\includegraphics[scale=0.6]{../matlab/dd_plot2}
\end{center}
\caption{Output response of controller built using Direct Design
compared to no control.  For no control this is the same plot
as in Figure \ref{fig:em_plot4} which stabilizes after a second.
The Matlab source performing these calculations and producing this
plot is given in Appendix \ref{app:dd_matlab}.}
\label{fig:dd_plot2}
\end{figure}
% }}}

While this result is positive it is not apparent whether it is within
the mechanical limits of a real engine.
In particular the control input should be limited to a range from zero to one.
Further investigation is needed to determine whether these limits
are being exceeded.
There is no doubt, however, that the addition of a controller
improved performance.
If the limits are being exceeded a different set of roots would have to
be chosen which may be less optimal.

% }}}

% {{{ Control Law, Intuitive Design
\clearpage
\section{Control Law, Intuitive Design}

% {{{ fig:clid01
\begin{figure}[hpb!]
\begin{center}

\begin{tikzpicture}[>=triangle 60,
	node distance=14mm, auto]

	\node[gain]  	(Gz)	[] 	{$G(z)$};
	\node[gain] 	(K)	[below=of Gz] 	{$K$};

	 \draw [->]
	 		(Gz.east) -- ++(15mm,0)
			-| ++(0,-10mm)
			|- (K.east);

	 \draw [<-]
	 		(Gz.west) -- ++(-15mm,0)
			-| ++(0,-10mm)
			|- (K.west);
\end{tikzpicture}

\end{center}

\caption{Control Law regulator system.
Typically, $-K$ is used to create negative feedback.}
\label{fig:clid01}
\end{figure}
% }}}

A Control Law Design\autocite[Pg. 280]{franklin1998digital} configured
as a regulator is shown in Figure \ref{fig:clid01}.
Notice that there is no input which means it acts as a regulator as
opposed to a servo.

There are several requirements that must be met in order for this
system to be stable.
First, the input to $G(z)$ must reflect the output without any offset.
And second the system must stabilize at zero.
These requirements can be verified intuitively.
Suppose for an input of $1$ to $G(z)$ an output of $5$ is produced.
What value of $K$ will produce a stable value?

\begin{align*}
	5 K &= 1 \\
	K &= \frac{1}{5}
\end{align*}

Now suppose a disturbance is introduced causing the output to increase
to $6$, will the system stabilize?

\begin{align*}
	6 \cdot K &= y \\
	6 \cdot \frac{1}{5} &= \frac{6}{5} \\
	\frac{6}{5} &> 1 \quad \text{(diverge)}
\end{align*}

An increase in the output creates positive feedback which increases
the input causing a further increase in the output.
The system diverges.
This exercise can be repeated with a controller that has no offset at zero.
The result is a negative feedback system that will stabilize at zero.

The linear engine model with zero torque (Equation \ref{eq:lems})
satisfies neither of these requirements.
The input does not reflect the output; the input range is from zero to
one whereas the output range is from 200 to 1200.
And operation at zero rpm is not realistic.

% {{{ fig:clid02
\begin{figure}[!htp]
\begin{center}

\begin{tikzpicture}[>=triangle 60,
	node distance=14mm, auto]

	\node[sumxpxp]  	(sum1)	[]				{};
	\node[gain]  	(R)		[right=of sum1] 	{$R$};
	\node[gain]  	(Gz)	[right=of R] 		{$G(z)$};
	\node[sumxpxn]	(sum2)	[right=of Gz]		{};
	\node[gain] 	(K)		[below=of Gz] 		{$-K$};

	\draw [<-] (sum1.north) -- ++(0,10mm) node[above]{$\text{rpm}$};
	\draw [->] (sum1.east) -- (R.west);
	\draw [->] (R.east) -- (Gz.west);
	\draw [->] (Gz.east) -- (sum2.west);
	\draw [<-] (sum2.north) -- ++(0,10mm) node[above]{$\text{rpm}$};
	\draw [->] (sum2.east) -- ++(10mm,0) node[above,xshift=-3mm]{$y$}
		-| ++(0,-10mm)
		|- (K.east);
	 \draw [<-] 
	 		(sum1.west) -- ++(-10mm,0) node[above,xshift=3mm]{$u$}
			|- (K.west);
\end{tikzpicture}

\end{center}

\caption{Compensations added to the linear engine model with zero
torque ($G(z)$) to construct a regulator system.
The transfer function $R$ converts rpm input to control output (0 - 1).
The rpm input is the desired idle speed (e.g. 700).
Notice that both the output ($y$) and input ($u$) will be zero when
the desired rpm is reached.}
\label{fig:clid02}
\end{figure}
% }}}

The system in Figure \ref{fig:clid02} adds compensations to the
engine model so that a regulator system can be constructed.
An input of zero should produce the desired rpm.
And this rpm input is converted to a control value ($R$).
And the reached rpm (output of $G(z)$) is subtracted from
the goal rpm to produce a zero output.

% {{{ fig:cl_plot1
\begin{figure}[!htp]
\begin{center}
\includegraphics[scale=0.6]{../matlab/cl_ff01}
\end{center}
\caption{Output response of Control Law regulator with $K = 0.01$
and rpm = $700$.
Rpm was allowed to stabilize at 200 rpm before applying a step
to 700 rpm.
Source code is provided in Appendix \ref{app:cl_matlab}.}
\label{fig:cl_plot1}
\end{figure}
% }}}

Figure \ref{fig:cl_plot1} shows the response of this system.
While the response isn't very good the design was trivial.
A value for $K$ was arbitrarily chosen.
Any values less than one were stable and larger values diverged.
Later designs will improve performance by elaborating upon this
system and developing more complex values for $K$.

% }}}

\clearpage
\section{Conclusion}

% TODO

\clearpage
\appendix

% {{{ Steady State to Delta Transform Derivation
\clearpage
\section{Steady State to Delta Transform Derivation}
\label{app:cdelta}

To accumulate a steady state input to produce a delta output
a system can be constructed as shown in Figure \ref{fig:cd1}.
Its operation can be confirmed by trying some values.
If all values are zero and then a $1$ is input on $u$ the
output will become $1$.
On the next time step $1$ will be output on $v$.
Since $q$ is zero $r$ will be $1$.
If the input ($u$) remains $1$ this will be subtracted from $r$
to produce zero on the output ($y$).

% {{{ fig:cd1
\begin{figure}[hpb!]
\begin{center}

\begin{tikzpicture}[>=triangle 60,
	node distance=14mm, auto]

	\node[sumnp]  	(sum1)	[] 					{};
	\node[sumxpxp] 	(sum2)	[below=of sum1] 	{};
	\node[gain] 	(gain1)	[right=of sum2]		{$z^{-1}$};
	\node[gain] 	(gain2)	[left=of sum2]		{$z^{-1}$};

	\draw [->] (sum2.north) -- 					(sum1.south);
	\draw [->] (gain1.west) -- node[below]{$v$} 	(sum2.east);
	\draw [->] (gain2.east) -- node[below]{$q$} 	(sum2.west);

	 \draw [->]
	 		($ (sum1.south) - (0,7mm) $)
			-- ++(-35mm,0) node[below left,yshift=-3mm]{$r$} 
			|- (gain2.west);
	\draw [->]
			(-45mm,0) node[above] {$u$} to (sum1);
	\draw [->]
			(sum1) to (45mm,0) node[above] {$y$};
	\draw [->]
			($(sum1.east) + (33mm,0) $)
			|- (gain1);
\end{tikzpicture}

\end{center}

\caption{System to accumulate values to convert a steady state
input to a delta output.}
\label{fig:cd1}
\end{figure}

% }}}

Figure \ref{fig:cd_plot1} shows the response of this system given
an arbitrary input.
It can be seen that if the input is held constant the output (delta)
returns to zero as expected.

\begin{figure}[htbp!]
\includegraphics[scale=0.7]{../matlab/cd_plot1}
\caption{Response of full steady state input to delta output system
to an arbitrary input signal.
The upper plot is the input signal ($u$) and the lower plot is
the output response ($y$).
The Matlab source code is given in Listing \ref{lst:cd_plot1}.
}
\label{fig:cd_plot1}
\end{figure}

\begin{samepage}
However this full system can be simplified to a single transfer function.
Starting from the equations that define the system
\begin{align}
	r &= q + v \label{eq:cd1a} \\
	v &= y \cdot z^{-1} \label{eq:cd1b} \\
	q &= r \cdot z^{-1} \label{eq:cd1c} \\
	y &= u - r \label{eq:cd1d}
\end{align}
these can be algebraically manipulated to find the effective transfer
function of the entire system ($y/u$).
\end{samepage}

\begin{align*}
	r &= r z^{-1} + y z^{-1} && (\ref{eq:cd1a}, \ref{eq:cd1b}, \ref{eq:cd1c})\\
	r(1 - z^{-1}) &= y z^{-1} \\
	r &= u - y && (\ref{eq:cd1d} \\
	(u - y)(1 - z^{-1}) &= y z^{-1} \\
	u - y - u z^{-1} + y z^{-1} &= y z^{-1} \\
	u - y - u z^{-1} &= 0 \\
	y &= u (1 - z^{-1})
\end{align*}
\begin{align}
	\Aboxed{ \frac{y}{u} &= 1 - z^{-1} }
\end{align}

\begin{figure}[!htbp]
\begin{center}

\begin{tikzpicture}[>=triangle 60]
\node[gain] (gain1) [] {$1 - z^{-1}$};
\draw [->] (-20mm,0) node[above,yshift=1mm]{$u$} -- (gain1.west);
\draw [->] (gain1.east) -- (20mm,0) node[above,yshift=1mm]{$y$};
\end{tikzpicture}

\end{center}
\caption{Simplified system to convert a steady state input in to
a delta output.}
\label{fig:cd1s}
\end{figure}

It can be seen in Figure \ref{fig:cd_plot2} that the simplified system
behaves identically to the previous system (Figure \ref{fig:cd_plot1}).

\begin{figure}[htbp!]
\includegraphics[scale=0.7]{../matlab/cd_plot2}
\caption{Response of simplified steady state input to delta output system
to an arbitrary input signal.
The upper plot is the input signal ($u$) and the lower plot is
the output response ($y$).
Response is identical to the full system in Figure \ref{fig:cd_plot1}
as expected.
The Matlab source code is given in Listing \ref{lst:cd_plot2}.
}
\label{fig:cd_plot2}
\end{figure}

\clearpage
\subsection{Matlab Source}
\label{app:cdsrc}

\nocite{octave}

\lstinputlisting[caption={Matlab code to plot the full steady state
to delta system.},
	label=lst:cd_plot1
	]{../matlab/cd_plot1.m}

\clearpage
\lstinputlisting[caption={Matlab code to plot the simplified steady state
to delta system.},
	label=lst:cd_plot2
	]{../matlab/cd_plot2.m}

% }}}

% {{{ Delta to Steady State Transform Derivation
\clearpage
\section{Delta to Steady State Transform Derivation}
\label{app:dsderiv}

To convert a delta input to a steady state output it should
sum the history of values.
Figure \ref{fig:dc1} shows the system.

% {{{ fig:dc1
\begin{figure}[hpb!]
\begin{center}

\begin{tikzpicture}[>=triangle 60,
	node distance=14mm, auto]

	\node[sumpp]  	(sum1)	[] 						{};
	\node[gain] 	(gain1)	[below right=of sum1]	{$z^{-1}$};

	\draw [->] (gain1.west) -| (sum1.south) node[left,yshift=-10mm]{$r$};
	\draw [<-] (sum1.west) -- ++(-20mm,0) node[above]{$u$};
	\draw [->] (sum1.east) -- (50mm,0) node[above]{$y$};
	\draw [->] ($ (sum1.east) + (30mm,0) $)
			|- (gain1.east);
\end{tikzpicture}

\end{center}

\caption{System to convert delta input to steady state output.}
\label{fig:dc1}
\end{figure}
% }}}

This system can be simplified in to a single transfer function
as given by Equation \ref{eq:dc2s} and shown in Figure \ref{fig:dc1s}.

\begin{align}
	y &= u + r \notag \\
	r &= y \cdot z^{-1} \notag \\
	y &= u + y z^{-1} \notag \\
	u &= y(1 - z^{-1}) \notag \\
	\Aboxed{ \frac{y}{u} &= \frac{1}{1 - z^{-1}} } \label{eq:dc2s}
\end{align}

% {{{ fig:dc1s
\begin{figure}[!htbp]
\begin{center}

\begin{tikzpicture}[>=triangle 60]
	\node[gain] (gain1) [] {$\dfrac{1}{1 - z^{-1}}$};
\draw [->] (-20mm,0) node[above,yshift=1mm]{$u$} -- (gain1.west);
\draw [->] (gain1.east) -- (20mm,0) node[above,yshift=1mm]{$y$};
\end{tikzpicture}

\end{center}
\caption{Simplified system to convert a delta input to
a steady state output.}
\label{fig:dc1s}
\end{figure}
% }}}

Figure \ref{fig:dc_plot2} shows the response of this system given
an arbitrary input
\footnote{This input is actually the output of the steady state input
to delta output given in Appendix \ref{app:cdelta}.
They are equal and opposite as expected.}.
It can be seen that the output is held in a steady state according
to the delta inputs as expected.

% {{{ fig:dc_plot2
\begin{figure}[htbp!]
\includegraphics[scale=0.7]{../matlab/dc_plot2}
\caption{Response of delta input to steady state output system
when given an arbitrary input signal.
The upper plot is the input signal ($u$) and the lower plot is
the output response ($y$).
The Matlab source code is given in Listing \ref{lst:dc_plot2}.
}
\label{fig:dc_plot2}
\end{figure}
% }}}

\clearpage
\subsection{Matlab Source}
\label{app:dcsrc}

\nocite{octave}

\lstinputlisting[caption={Matlab code to plot the simplified steady state
to delta system.},
	label=lst:dc_plot2
	]{../matlab/dc_plot2.m}

% }}}

% {{{ Control Response
\clearpage
\section{Control Response}
\label{app:contrpm}

For a given control input and zero torque the engine model will
reach stable rpm values as shown in Figure \ref{fig:stable}.
Equation \ref{eq:stable} describes its behavior.
Listing \ref{lst:stable} shows how this was calculated.

\begin{align}
y &= 1450.1 x \label{eq:stable} \\
	y &: \text{rpm (200 - 1200)} \notag \\
	x &: \text{control (0 - 1)} \notag
\end{align}

\begin{figure}[htbp!]
\begin{center}
\includegraphics[scale=0.5]{../matlab/em_plot3}
\end{center}
\caption{Stable rpm reached for a given constant control input.}
\label{fig:stable}
\end{figure}

\clearpage
\lstinputlisting[
	caption={Matlab source to find the stable rpm for a given
		control input.},
	label={lst:stable}
	]{../matlab/em_plot3.m}
% }}}

% {{{ Engine Model Matlab Source
\clearpage
\section{Engine Model Matlab Source}
\label{app:em_matlab}

\lstinputlisting[
	caption={Matlab source to calculate the engine model system with
		zero torque.  This function is called by other scripts that
	use this model.}
	]{../matlab/engine_model.m}

\lstinputlisting[
	caption={Matlab source to plot the response of engine model
		with no control. The $x$ axis is in ticks.}
	]{../matlab/em_plot1.m}

% XXX
\clearpage
\lstinputlisting[
	caption={Matlab source to plot the response of engine model
	with no control.  The $x$ axis is in time.}
	]{../matlab/em_plot2.m}

\clearpage
\lstinputlisting[
	caption={Matlab source to plot the response of engine model
		versus time for a typical 600 to 1000 rpm range.}
	]{../matlab/em_plot4.m}
% }}}

% {{{ General Matlab Functions
\clearpage
\section{General Matlab Functions}
\label{app:gf_matlab}

This sections includes Matlab source for functions which are
used among several methods.

\lstinputlisting[
	caption={Matlab source of function to calculate a Sylvester Matrix.} 
	]{../matlab/sylvester.m}

\lstinputlisting[
	caption={Matlab source of function to calculate zero time.} 
	]{../matlab/zerotime.m}

\clearpage
\lstinputlisting[
	caption={Matlab source of modified lsim() function.} 
	]{../matlab/lsim1.m}

% }}}

% {{{ Direct Design Matlab Source
\clearpage
\section{Direct Design Matlab Source}
\label{app:dd_matlab}

Matlab source code used to build a controller using Direct Design
and plot the output.
The \verb+engine_model+ is given in Appendix \ref{app:em_matlab}
and other functions are given in Appendix \ref{app:gf_matlab}.

\lstinputlisting[
	caption={Matlab source of function is to build a controller using
		Direct Design.}
	]{../matlab/direct_design.m}

\clearpage
\lstinputlisting[
	caption={Matlab source used to plot the controller built using
	Direct Design compared to no control.}
	]{../matlab/dd_plot2.m}

% }}}

% {{{ Control Law Matlab Source
\clearpage
\section{Control Law Matlab Source}
\label{app:cl_matlab}

Matlab source code used to the Control Law regulator.

\lstinputlisting[
	caption={Matlab source used to plot the Control Law regulator.}
	]{../matlab/cl_ff01.m}

% }}}

% {{{ Colophon
\clearpage
\section{Colophon}
\label{app:colophon}

This written in \LaTeX and built using Pdflatex.
The block diagrams were written using TikZ\autocite{tikz}.
All calculations and plots were run using version 3.6.4 of
Octave\autocite{octave}, an open source Matlab clone.
Except for a few instances (\verb+cl_fonp02.m+, \verb+cl_fonp03.m+) the
M-Files are completely compatible between both Octave and Matlab.
The entire control system is built within the M-File and has
no dependence on Simulink.
Octave uses the Octave Control (CACSD) Tools\autocite{octave-control} 
which have equivalents in Matlab.
In a few cases an equivalent Simulink diagram was built and in
each of the cases the results agreed.
This document and all of its code are released under the
GNU General Public License and freely
available\autocite{github_jmahler_idle-control}.
\nocite{github_jmahler_control}

% }}}

% References
\clearpage
\printbibliography[heading=bibintoc]

\end{document}
