
% {{{ preamble

%\documentclass[10pt,letterpaper]{article}
\documentclass{article}
%\documentclass[twocolumn]{article}
%\documentclass[12pt]{report}

%\usepackage{url}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{nonfloat}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{parskip}
\usepackage{fullpage}

\usepackage{tikz}
\usetikzlibrary{calc,arrows,positioning,shadows}
%
% control system tikz objects
\tikzset{shadow/.style={drop shadow,fill=white}}
\tikzset{sum/.style={circle,draw,very thick,shadow,minimum size=6mm}}
\tikzset{sumnp/.style={sum,
				label={{above left,xshift=0.0mm,yshift=-1.0mm}:$+$},
				label={{below right,xshift=-1.0mm,yshift=0.0mm}:$-$}} }
\tikzset{sumpp/.style={sum,
				label={{above left,xshift=0.0mm,yshift=-1.0mm}:$+$},
				label={{below right,xshift=-1.0mm,yshift=0.0mm}:$+$}} }
\tikzset{sumpn/.style={sum,
				label={{below left,xshift=0.0mm,yshift=1.0mm}:$+$},
				label={{above right,xshift=-1.0mm,yshift=0.0mm}:$-$}} }
\tikzset{sumxpxp/.style={sum,
				label={{above left,xshift=0.0mm,yshift=-1.0mm}:$+$},
				label={{above right,xshift=-0.0mm,yshift=-1.0mm}:$+$}} }
\tikzset{gain/.style={rectangle,draw,very thick,inner sep=2mm,shadow}}

\usepackage{listings}
\lstset{numbers=left,
		language=Matlab,
		basicstyle=\footnotesize,
		captionpos=b,
		showspaces=false,
		showstringspaces=false,
		xleftmargin=0.3in}

\usepackage{sectsty}  % \sectionfont
\sectionfont{\normalsize}
\subsectionfont{\normalsize}

\raggedright
%\setlength{\parindent}{0.2in}

%
% backend	: biber
% style		: numeric
% autocite	: footnote
% citestyle	: verbose-inote
% bibstyle	: authortitle, numeric
%
\usepackage[backend=biber,autocite=footnote,
			bibstyle=authortitle,citestyle=verbose-inote]{biblatex}

\addbibresource{main.bib}
\setlength\bibitemsep{1em}

% }}}

\begin{document}

% {{{ title page

\thispagestyle{empty}

\centerline{\Large \textbf{Control System Design Applied to}}
\centerline{\Large \textbf{Idle Stabilization of a Spark Ignition Engine}}
\vspace{0.1in}
\centerline{\normalsize {Jeremiah Mahler}}
\centerline{\small {\href{mailto:jmahler@mail.csuchico.edu}{jmahler@mail.csuchico.edu}} }
\vspace{0.1in}
\centerline{\normalsize {CSU Chico}}
%\centerline{\today}
%\vspace{0.1in}
\centerline{\small \today}
\vspace{0.2in}
\centerline{\LARGE \textbf{DRAFT}}
\vspace{0.2in}

% }}}

% {{{ abstract
%\pagebreak
%\thispagestyle{empty}
\begin{abstract}
\noindent
The task of maintaining a stable idle for an internal combustion
engine with spark ignition is non-trivial.
Any time an accessory is turned on/off the torque applied to
the engine changes.
And changes in torque will change the engine rpm if the control
inputs are constant.
This paper shows how control systems methods can be applied to
the problem of idle stabilization.
Methods include: pole placement, direct design, and
various state space designs.

\end{abstract}
% }}}

% {{{ Engine Model
\section{Engine Model}

The engine model used here is based work
by Butts and Sivashankar\autocite{532315} which was derived from
the work by Powell and Cook\autocite{4789342}.
The configuration is a modern 4.6L V-8 gas engine.
A single control input representing the idle air bypass valve 

To simplify analysis the linearized model is used as shown in
Figure \ref{fig:lem}.

\begin{figure}[hbp!]
\begin{center}

\begin{tikzpicture}[>=triangle 60, scale=0.7,
	node distance=14mm, auto]

	\node[gain] 	(gain1)	[]					{$1.699$};
	\node[sumnp]  	(sum1)	[right=of gain1] 	{};
	\node[gain] 	(gain2)	[right=of sum1]		{$\dfrac{8.5683}{z^2-0.9025z}$};
	\node[sumpn]  	(sum2)	[right=of gain2] 	{};
	\node[gain] 	(gain3)	[right=of sum2]		{$\dfrac{2.98}{z - 0.9354}$};
	\node[gain] 	(gain4)	[below=of sum2]		{$0.00093$};

	\draw [->] (-20mm,0) node[above]{$\Delta \text{control}$} -- (gain1.west);
	\draw [->] (gain1) -- (sum1);
	\draw [->] (sum1) -- (gain2);
	\draw [->] (gain2) -- (sum2);
	\draw [->] (sum2) -- (gain3);
	\draw [->] (gain3.east) -- ++(20mm,0) node[above]{$\Delta \text{rpm}$};
	\draw [->] ($(gain3.east) + (10mm,0) $) |- (gain4.east);
	\draw [->] (gain4.west) -| (sum1.south);
	\draw [<-] (sum2.north) -- ++(0,10mm) node[above]{$\Delta \text{torque}$};
\end{tikzpicture}

\end{center}
\caption{Linear engine model of a modern 4.6L V-8.}\label{fig:lem}
\end{figure}

This model takes two inputs: a torque, and a idle control signal.
When the torque is greater than zero it will oppose the rotation of
the engine causing it to slow down.
The idle control signal is some fraction of unity.
This fraction corresponds to a pulse width modulated idle control valve
which is at a minimum near zero and at a maximum near unity.
Often the duty cycle range is in a range from 0\% to 100\% which
corresponds to 0 to 1 (unity).

Because all the inputs and outputs are defined as deltas ($\Delta$)
this model cannot be used directly with typical control systems
which use steady state values.
It is possible convert these deltas to steady state equivalents.
Figure \ref{fig:sdtf} shows the transfer function to convert steady
state values to delta values.
Figure \ref{fig:dstf} shows the transfer function to delta values
to steady state values.

% {{{ fig:sdtf
\begin{figure}[!htbp]

\begin{center}
\begin{tikzpicture}[>=triangle 60]
\node[gain] (gain1) [] {$1 - z^{-1}$};
\draw [->] (-20mm,0) node[above,yshift=1mm]{$X$} -- (gain1.west);
\draw [->] (gain1.east) -- (20mm,0) node[above,yshift=1mm]{$\Delta X$};
\end{tikzpicture}
\end{center}

\caption{The $Z$ transform used to accumulate the input and convert
a steady state input to delta output.
Its derivation is given in Appendix \ref{app:cdelta}.}
\label{fig:sdtf}

\end{figure}
% }}}

% {{{ fig:dstf
\begin{figure}[!htbp]

\begin{center}
\begin{tikzpicture}[>=triangle 60]
\node[gain] (gain1) [] {$\dfrac{1}{1 - z^{-1}}$};
\draw [->] (-20mm,0) node[above,yshift=1mm]{$\Delta X$} -- (gain1.west);
\draw [->] (gain1.east) -- (20mm,0) node[above,yshift=1mm]{$X$};
\end{tikzpicture}
\end{center}

\caption{The $Z$ transform used to convert delta input to a steady
state output.
Its derivation is given in Appendix \ref{app:dsderiv}.}
\label{fig:dstf}

\end{figure}
% }}}

Typical control systems have an associated time step.
And the choice of this time step is crucial in determining performance
with regard to the Nyquist frequency.
However this model does not suffer from this issue because it is
inherently discrete.
A single ignition event of the engine corresponds to a single
step of the model.

% TODO - reduced steady state system

In order to build a controller the model needs to be simplified
but the presence of two inputs complicates matters.
To resolve this issue the torque can be set zero.
Then it can be simplified by recognizing that it matches
the well known form shown in Figure \ref{fig:dd} which
has the transfer function in Equation \ref{eq:dd}.

% {{{ dd figure
\begin{figure}[h!]

\begin{center}
\begin{tikzpicture}[>=triangle 60, scale=0.8,
	node distance=20mm, auto]

	\node[gain]		(K) 	[] 				{$K$};
	\node[sumnp]	(sum1) 	[right of=K] 	{};
	\node[gain]		(Gz) 	[right of=sum1]	{$G(z)$};
	\node[gain]		(Dz) 	[below of=Gz] 	{$D(z)$};

	\draw [<-] (K) -- ++(-20mm,0) node[above]{$u$};
	\draw [->] (K) -- (sum1);
	\draw [->] (sum1) -- (Gz);
	\draw [<-] (sum1) |- (Dz);
	\draw [->] (Gz) -- ++(35mm,0) node[above]{$y$};
	\draw [->] (Gz) -- ++(20mm,0) |- (Dz.east);
\end{tikzpicture}
\end{center}

\caption{Direct Design system with $K$ as a scaling input, $G$ is
the plant and $D$ is the controller.}
\label{fig:dd}
\end{figure}
% }}}

\begin{align}
\frac{y}{u} &= K \frac{B \alpha}{A \alpha + B \beta} \label{eq:dd}
\end{align}

First taking the parts from the engine model (Figure \ref{fig:lem}).

\begin{align*}
	\frac{B}{A} &= \frac{8.5683}{(z^2 - 0.9025z)} \frac{2.98}{(z - 0.9354)} \\
	K &= 1.699 \\
	\frac{\beta}{\alpha} &= 0.00093 
\end{align*}

\begin{samepage}
Then substituting them in to Equation \ref{eq:dd} and simplifying
results in Equation \ref{eq:lems}.
\begin{align}
	\frac{y}{u} &= \frac{(1.699) (8.5683) (2.98) (1)}
		{(z^2 - 0.9025z)(z - 0.9354)(1) + (8.5683)(2.98)(0.00093)} \notag \\
	\Aboxed{ \frac{y}{u} &= \frac{43.38}{z^3 - 1.838 z^2 + 0.8442 z + 0.02375}}
		\label{eq:lems}
\end{align}
\end{samepage}

\begin{samepage}
It is still necessary to address the delta inputs and outputs.
This can be resolved by placing the conversion transforms,
from Figure \ref{fig:sdtf} and \ref{fig:dstf}, on either
end of the engine model transfer function as shown in Figure \ref{fig:nodelta}.
A beneficial side effect becomes apparent in this form.
The transform that converts from steady state to a delta cancels
with the transform that converts from a delta to steady state
\footnote{In the more general case, when torque is non zero,
the transforms would not cancel.}.
Therefore the final transform is still Equation \ref{eq:lems}.
An example of the output response with no control is shown in
Figure \ref{fig:em_plot}.
\end{samepage}

% {{{ fig:nodelta
\begin{figure}[!htbp]

\begin{center}
\begin{tikzpicture}[>=triangle 60,
	node distance=30mm, auto]

\node[gain] (gain1) [] {$1 - z^{-1}$};
\node[gain] (engine) [right of=gain1] {engine};
\node[gain] (gain3) [right of=engine] {$\dfrac{1}{1 - z^{-1}}$};

\draw [->] (-25mm,0) node[above]{$u$} -- (gain1.west);
\draw [->] (gain1.east) node[above,xshift=6mm]{$\Delta u$} -- (engine);
\draw [->] (engine.east) node[above,xshift=6mm]{$\Delta y$} -- (gain3);
\draw [->] (gain3.east) -- ++(20mm,0) node[above]{$y$};
\end{tikzpicture}
\end{center}

\caption{Engine model with transforms for converting from steady state
to delta and vice versa.}
\label{fig:nodelta}

\end{figure}
% }}}

% {{{ fig:em_plot
\begin{figure}[htbp!]
\begin{center}
\includegraphics[scale=0.7]{../octave/engine_model_plot}
\end{center}
\caption{Output response of engine model with no control.
The control can range from zero to one.
Here the control is constant at 0.65 which resulted in a stable
rpm near 900.\protect\footnotemark}
\label{fig:em_plot}
\end{figure}
\footnotetext{The Matlab source to produced these plots is in Appendix \ref{app:em_matlab}.}
% }}}

It is not apparent from Figure \ref{fig:em_plot} exactly how long
this process takes.
The $x$ axis represents ignition events, not time.
The rpm can be converted to time per ignition event by examining
the units as shown in Equation \ref{eq:rpmtime}.

\begin{align}
\frac{1}{x \frac{\text{rev}}{\text{min}}
			\cdot n \frac{\text{ign}}{\text{rev}}
			\cdot \frac{\text{min}}{60\text{sec}}
		}
&= y \frac{\text{sec}}{\text{ign}} \label{eq:rpmtime} \\
& \notag \\
	\frac{\text{rev}}{\text{min}} &: \text{revolutions per minute (rpm)} \notag \\
	\frac{\text{ign}}{\text{rev}} &: \text{number ignition points per revolution (4 for 8 cylinder engine)} \notag \\
	\frac{\text{sec}}{\text{ign}} &: \text{seconds per ignition point} \notag
\end{align}

Applying this equation results in the response shown
in Figure \ref{fig:rpmtime_plot}.
It can be seen it takes over two seconds for the system to
stabilize with no control.
Clearly this is unacceptably slow and performance could be
improved by using a controller.

% {{{ fig:rpmtime_plot
\begin{figure}[htbp!]
\begin{center}
\includegraphics[scale=0.7]{../octave/engine_model_rpmtime_plot}
\end{center}
\caption{Engine rpm response compared to time with a constant
0.65 input control.\protect\footnotemark}
\label{fig:rpmtime_plot}
\end{figure}
\footnotetext{The Matlab source of the RPM vs time plot is in Appendix \ref{app:rpmtime_plot_source}.}
% }}}

There is yet another complication with this model.
Typical systems are in a normalized so that it is possible to
achieve an output of one given a step input.
With this engine model an output of 1 rpm is an impossibly slow value.
And an input of zero or one rpm are similarly impossible.

To resolve this issue the values will be scaled in to a normal range.
A normal idle rpm range is from 600 to 1200 rpm.
To scale these values so that zero equals 600 and one equals 1000
Equation \ref{eq:scale} can be used.

\begin{align}
	y &= \frac{1}{400}x - \frac{3}{2} \label{eq:scale}
\end{align}

Figure \ref{fig:stable} shows the stable rpms for a given control input.
Its behavior is described by Equation \ref{eq:stable}.

\begin{align}
	y &= 1450.1 x \label{eq:stable}
\end{align}

% {{{ fig:stable
\begin{figure}[htbp!]
\begin{center}
\includegraphics[scale=0.6]{../octave/stable_rpm_plot}
\end{center}
\caption{Stable rpm reached for a given constant control input.}
\label{fig:stable}
\end{figure}
% }}}

With these normalization corrections applied the response can be
seen in Figure \ref{fig:normeng}.
To avoid the zero rpm case it is allowed to stabilize before the
step is applied.
The lowest plot shows the response after the step.
It takes slightly over one second to stabilize, which is better than
the inaccurate case from zero rpm, but it is still slow and can
be improved.

% {{{ fig:normeng
\begin{figure}
\begin{center}
\includegraphics[scale=0.7]{../octave/norm_engine_model_plot}
\includegraphics[scale=0.55]{../octave/norm_engine_plot_close}
\end{center}
\caption{Normalized engine model response.  After it stabilizes
at unit step is applied to produce the normalized response.
The lowest plot is a close up of the step response in the center
plot.}
\label{fig:normeng}
\end{figure}
% }}}

% }}}

\clearpage

% {{{ Pole Placement
\section{Pole Placement}

% }}}

% {{{ Regulator Control System
\clearpage
\section{Regulator Control System}

What is needed is a regulator system where the input is applied
as torque.
The general system is shown in Figure \ref{fig:rpm1}.

% {{{ fig:rpm1, Regulator System
\begin{figure}[hbp!]
\begin{center}

\begin{tikzpicture}[>=triangle 60, scale=0.8,
	node distance=14mm, auto]

	\node[gain] 	(engine)	[]					{engine};
	\node[gain] 	(control)	[below=of engine]	{controller};

	\draw [<-] (engine.north) -- ++(0,10mm) node[above]{$\text{torque}$};
	\draw [->] (engine.east) node[above,xshift=7mm]{rpm}
					-- ++(20mm,0)
					|- (control.east);
	\draw [->] (control.west)
					-- ++(-20mm,0)
					|- (engine.west) node[above,xshift=-9mm]{control};
\end{tikzpicture}

\end{center}
\caption{General system for regulating engine rpm.}\label{fig:rpm1}
\end{figure}
% }}}

% }}}

\clearpage
\section{Conclusion}

% References
\clearpage
\printbibliography[heading=bibintoc]

\clearpage
\appendix

% {{{ Steady State to Delta Transform Derivation
\clearpage
\section{Steady State to Delta Transform Derivation}
\label{app:cdelta}

To accumulate a steady state input to produce a delta output
a system can be constructed as shown in Figure \ref{fig:cd1}.
Its operation can be confirmed by trying some values.
If all values are zero and then a $1$ is input on $u$ the
output will become $1$.
On the next time step $1$ will be output on $v$.
Since $q$ is zero $r$ will be $1$.
If the input ($u$) remains $1$ this will be subtracted from $r$
to produce zero on the output ($y$).

% {{{ fig:cd1
\begin{figure}[hpb!]
\begin{center}

\begin{tikzpicture}[>=triangle 60,
	node distance=14mm, auto]

	\node[sumnp]  	(sum1)	[] 					{};
	\node[sumxpxp] 	(sum2)	[below=of sum1] 	{};
	\node[gain] 	(gain1)	[right=of sum2]		{$z^{-1}$};
	\node[gain] 	(gain2)	[left=of sum2]		{$z^{-1}$};

	\draw [->] (sum2.north) -- 					(sum1.south);
	\draw [->] (gain1.west) -- node[below]{$v$} 	(sum2.east);
	\draw [->] (gain2.east) -- node[below]{$q$} 	(sum2.west);

	 \draw [->]
	 		($ (sum1.south) - (0,7mm) $)
			-- ++(-35mm,0) node[below left,yshift=-3mm]{$r$} 
			|- (gain2.west);
	\draw [->]
			(-45mm,0) node[above] {$u$} to (sum1);
	\draw [->]
			(sum1) to (45mm,0) node[above] {$y$};
	\draw [->]
			($(sum1.east) + (33mm,0) $)
			|- (gain1);
\end{tikzpicture}

\end{center}

\caption{System to accumulate values to convert a steady state
input to a delta output.}
\label{fig:cd1}
\end{figure}

% }}}

Figure \ref{fig:cd1_plot} shows the response of this system given
an arbitrary input.
It can be seen that if the input is held constant the output (delta)
returns to zero as expected.

\begin{figure}[htbp!]
\includegraphics[scale=0.7]{../octave/cd1_plot}
\caption{Response of full steady state input to delta output system
to an arbitrary input signal.
The upper plot is the input signal ($u$) and the lower plot is
the output response ($y$).
The Matlab source code is given in Listing \ref{lst:cd1_init}
and \ref{lst:cd1_plot}.
}
\label{fig:cd1_plot}
\end{figure}

\begin{samepage}
However this full system can be simplified to a single transfer function.
Starting from the equations that define the system
\begin{align}
	r &= q + v \label{eq:cd1a} \\
	v &= y \cdot z^{-1} \label{eq:cd1b} \\
	q &= r \cdot z^{-1} \label{eq:cd1c} \\
	y &= u - r \label{eq:cd1d}
\end{align}
these can be algebraically manipulated to find the effective transfer
function of the entire system ($y/u$).
\end{samepage}

\begin{align*}
	r &= r z^{-1} + y z^{-1} && (\ref{eq:cd1a}, \ref{eq:cd1b}, \ref{eq:cd1c})\\
	r(1 - z^{-1}) &= y z^{-1} \\
	r &= u - y && (\ref{eq:cd1d} \\
	(u - y)(1 - z^{-1}) &= y z^{-1} \\
	u - y - u z^{-1} + y z^{-1} &= y z^{-1} \\
	u - y - u z^{-1} &= 0 \\
	y &= u (1 - z^{-1})
\end{align*}
\begin{align}
	\Aboxed{ \frac{y}{u} &= 1 - z^{-1} }
\end{align}

\begin{figure}[!htbp]
\begin{center}

\begin{tikzpicture}[>=triangle 60]
\node[gain] (gain1) [] {$1 - z^{-1}$};
\draw [->] (-20mm,0) node[above,yshift=1mm]{$u$} -- (gain1.west);
\draw [->] (gain1.east) -- (20mm,0) node[above,yshift=1mm]{$y$};
\end{tikzpicture}

\end{center}
\caption{Simplified system to convert a steady state input in to
a delta output.}
\label{fig:cd1s}
\end{figure}

It can be seen in Figure \ref{fig:cd2_plot} that the simplified system
behaves identically to the previous system (Figure \ref{fig:cd1_plot}).

\begin{figure}[htbp!]
\includegraphics[scale=0.7]{../octave/cd2_plot}
\caption{Response of simplified steady state input to delta output system
to an arbitrary input signal.
The upper plot is the input signal ($u$) and the lower plot is
the output response ($y$).
Response is identical to the full system in Figure \ref{fig:cd1_plot}
as expected.
The Matlab source code is given in Listing \ref{lst:cd2_init}
and \ref{lst:cd2_plot}.
}
\label{fig:cd2_plot}
\end{figure}

\clearpage
\subsection{Matlab Source}
\label{app:cdsrc}

The following code has been tested using Octave\autocite{octave},
an open source Matlab clone.

\lstinputlisting[caption={Matlab code to initialize the full
steady state to delta system.},
	label=lst:cd1_init
	]{../octave/cd1_init.m}

\lstinputlisting[caption={Matlab code to plot the full steady state
to delta system.},
	label=lst:cd1_plot
	]{../octave/cd1_plot.m}

\clearpage
\lstinputlisting[caption={Matlab code to initialize the simplified
steady state to delta system.},
	label=lst:cd2_init
	]{../octave/cd2_init.m}

\lstinputlisting[caption={Matlab code to plot the simplified steady state
to delta system.},
	label=lst:cd2_plot
	]{../octave/cd2_plot.m}

% }}}

% {{{ Delta to Steady State Transform Derivation
\clearpage
\section{Delta to Steady State Transform Derivation}
\label{app:dsderiv}

To convert a delta input to a steady state output it should
sum the history of values.
Figure \ref{fig:dc1} shows the system.

% {{{ fig:dc1
\begin{figure}[hpb!]
\begin{center}

\begin{tikzpicture}[>=triangle 60,
	node distance=14mm, auto]

	\node[sumpp]  	(sum1)	[] 						{};
	\node[gain] 	(gain1)	[below right=of sum1]	{$z^{-1}$};

	\draw [->] (gain1.west) -| (sum1.south) node[left,yshift=-10mm]{$r$};
	\draw [<-] (sum1.west) -- ++(-20mm,0) node[above]{$u$};
	\draw [->] (sum1.east) -- (50mm,0) node[above]{$y$};
	\draw [->] ($ (sum1.east) + (30mm,0) $)
			|- (gain1.east);
\end{tikzpicture}

\end{center}

\caption{System to convert delta input to steady state output.}
\label{fig:dc1}
\end{figure}
% }}}

This system can be simplified in to a single transfer function
as given by Equation \ref{eq:dc2s} and shown in Figure \ref{fig:dc1s}.

\begin{align}
	y &= u + r \notag \\
	r &= y \cdot z^{-1} \notag \\
	y &= u + y z^{-1} \notag \\
	u &= y(1 - z^{-1}) \notag \\
	\Aboxed{ \frac{y}{u} &= \frac{1}{1 - z^{-1}} } \label{eq:dc2s}
\end{align}

% {{{ fig:dc1s
\begin{figure}[!htbp]
\begin{center}

\begin{tikzpicture}[>=triangle 60]
	\node[gain] (gain1) [] {$\dfrac{1}{1 - z^{-1}}$};
\draw [->] (-20mm,0) node[above,yshift=1mm]{$u$} -- (gain1.west);
\draw [->] (gain1.east) -- (20mm,0) node[above,yshift=1mm]{$y$};
\end{tikzpicture}

\end{center}
\caption{Simplified system to convert a delta input to
a steady state output.}
\label{fig:dc1s}
\end{figure}
% }}}

Figure \ref{fig:dc2_plot} shows the response of this system given
an arbitrary input
\footnote{This input is actually the output of the steady state input
to delta output given in Appendix \ref{app:cdelta}.
They are equal and opposite as expected.}.
It can be seen that the output is held in a steady state according
to the delta inputs as expected.

% {{{ fig:dc2_plot
\begin{figure}[htbp!]
\includegraphics[scale=0.7]{../octave/dc2_plot}
\caption{Response of delta input to steady state output system
when given an arbitrary input signal.
The upper plot is the input signal ($u$) and the lower plot is
the output response ($y$).
The Matlab source code is given in Listing \ref{lst:dc2_init}
and \ref{lst:dc2_plot}.
}
\label{fig:dc2_plot}
\end{figure}
% }}}

\clearpage
\subsection{Matlab Source}
\label{app:dcsrc}

The following code has been tested using Octave\autocite{octave},
an open source Matlab clone.

%\lstinputlisting[caption={Matlab code to initialize the full
%steady state to delta system.},
%	label=lst:dc1_init
%	]{../octave/dc1_init.m}
%
%\lstinputlisting[caption={Matlab code to plot the full steady state
%to delta system.},
%	label=lst:dc1_plot
%	]{../octave/dc1_plot.m}

\lstinputlisting[caption={Matlab code to initialize the simplified
steady state to delta system.},
	label=lst:dc2_init
	]{../octave/dc2_init.m}

\lstinputlisting[caption={Matlab code to plot the simplified steady state
to delta system.},
	label=lst:dc2_plot
	]{../octave/dc2_plot.m}

% }}}

\clearpage
\section{Engine Model Matlab Source}
\label{app:em_matlab}
\label{app:rpmtime_plot_source}

\lstinputlisting[
	caption={Matlab source to calculate the engine model system with
		zero torque.}
	]{../octave/engine_model.m}

\lstinputlisting[
	caption={Matlab source to plot the response of engine model
		with no control.}
	]{../octave/engine_model_plot.m}

\clearpage
\lstinputlisting[
	caption={Matlab source to plot the response of engine model
		versus time.}
	]{../octave/engine_model_rpmtime_plot.m}

\clearpage
\lstinputlisting[
	caption={Matlab source to plot the response of the normalized engine model.}
	]{../octave/norm_engine_model_plot.m}

\clearpage
\lstinputlisting[
	caption={Matlab source to plot the response of the normalized engine model
	after step is applied.}
	]{../octave/norm_engine_plot_close.m}



\end{document}
